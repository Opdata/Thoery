분산시스템
- 작업의 분산
- 저장의 분산
- 통제서버가 있듯이 모든 노드가 동등하지는 않다.
- 여러 서버가 일을 나눠 처리함으로써 작업의 효율성, 가용성을 높이는 것이 주목적
- 분산된 일을 여러 서버가 처리함으로써 더 빨리 해결하고, 중앙서버가 고장나면 서비스가 중단되는 것을 방지해 가용성을 높이는 기술

탈중앙화 블록체인 시스템
- 작업의 반복
- 저장의 반복
- 모든 노드가 동등하다.
- 분산시스템의 극단적인 형태, 일을 분산해 처리하는 것이 아니라 동일한 일을 중복해 처리
- 더 많은 시간과 자원이 투입되지만, 일을 중복하기 떄문에 효율성이 극도로 저하, 그러나 모든 노드가 일을 반복한 후 결과를 일치시켜서
일에 대한 신뢰도가 향상됨. 즉 작업 효율성을 희생하는 대신 신뢰도를 높인 시스템

-> 네트워크에 참여하는 노드들이 많아져도 속도는 빨라지지 않는다.
-> 탈중앙화 블록체인 시스템이 효율적인 시스템은 아니다.
-> 블록체인의 핵심은 분산이 아닌 중복 이다, 모든 노드가 동등하며 효율을 포기하고 신뢰성을 높이는 시스템
-> 기록을 담당하는 노드를 신뢰하지 못하여 중복을 통해 검증한다.

블록체인은 데이터를 보호하지 못하며, 사용성이 떨어진다
-> 블록체인의 모든 데이터는 전체노드에 그대로 노출되며, 무결성 유지를 위해 데이터의 갱신과 저장이 극도로 불편하다.
-> 블록체인을 정보 저장의 용도로 사용해서는 안된다. (블록체인은 데이터베이스가 아니다) ex 이더리움 The DAO 사건

디지털화폐 : 디지털과 화폐를 조합한 광범위한 단어 ex 유통화폐를 디지털화 한것
암호화폐 : 가상화폐 중 익명성을 보장하기위한 기술이 들어가 있는 것
*모든 암호화폐는 익명성을 지니고 있다, 우리가 일반적으로 은행을 통해 거래하는 디지털화된 원화는 블록체인 기반 혹은 실험적화폐도 아니므로
디지털화폐 혹은 디지털통화로 부름

# 암호화폐 와 디지털화폐는 다른 용어이다.
-> 암호화폐는 수많은 디지털 화폐의 한 종류일 뿐, 암호화폐는 절대적으로 익명성을 가진다. 익명성이 모든 문제의 원인이기도 하다.

#암호화폐는 디지털 자산이 아니다.
-> 디지털자산 : 이미 가치를 갖고 있는 무엇이 디지털로 정보를 변환해 보관하고 있는 것
-> 암호화폐 : 가치를 가지고 있지 않은 것을 디지털화한 디지털 수치, 내재 가치는 '0' 이다.

암호화폐는 자발적인 네트워크가 형성된 후 충분한 채굴자 집단을 구성해 지속적인 채굴 노동을 제공해야 비로소 운영할 수 있다
네트워크를 운영할 참여자를 모집하고 일정 이상의 채굴 집단을 형성해 안정성을 확보하는 것이 지극히 힘들다.
* 이더리움의 경우 스마트 컨트랙트를 사용하여 별도의 네트워크 구성하지 않고 손쉽게 암호화폐를 발행할 수 있다.
-> 이더리움 네트워크를 그대로 활용해 화폐 발행과, 이체도 할 수 있다.

토큰(token) : 일반적인 의미로. 모든 종류의 보상을 통칭하는 광범위한 의미 , 무형의 의미도 포함됨
토큰(token) : 자체 네트워크를 갖추지 않고 이미 발행한 암호화폐를 자체 네트워크로 갖추고 발행된 암호화폐와 구분하기 위해 사용되는 용어
-> 자체네트워크를 메인넷(MainNet) 이라고도 한다.

트랜잭션(transaction) : 정의된 이벤트가 발생하는 것, 일반적인 의미로는 최소한의 업무 처리 단위
-> 중개소에서 이뤄지는 거래내역 같은 것은 트랜잭션이 아니다. 중개소는 자신들의 중앙화 서버에서 거래가 일어난 것처럼 꾸미기만 할뿐 고객의 별도 요청
(아마 지갑송금 등 을 말하는 것으로 예상)이 일어나기 전까지는 블록체인을 통한 거래가 일어나지 않기 떄문.
- 네트워크에 트랜잭션을 먼저 제출했다고 노드에 먼저 도달한다는 보장이 없다. 통상 수수료율이 더 높은 트랜잭션을 먼저 처리한다.

트랜잭션에 담긴 정보

비트코인 UTXO(unspent transaction output)
- 누군가에게 비트코인을 수령한 후 아직 사용하지 않은 상태로 블록에 남아 있는 항목들의 출력값
https://brunch.co.kr/@skkrypto/13
- 비트코인은 한곳에 모여 있지 않고 여러 블록에 산재해 저장돼 있다.(잔액들이, 지갑을 통해 모두 합산해 편리하게 보여준다.)

코인베이스(coin-base) 트랜잭션
- 모든 블록의 채굴 보상금이 생성되는 곳, 채굴한 사람에게 보상금을 지급해주는 트랜잭션
- 모든 블록의 첫번째 트랜잭션에 해당됨
- 코인베이스 트랜잭션을 제외한 나머지 트랜잭션은 모두 일반 트랜잭션 이라고 함.
note. 블록이 폐기가 될때가 있고 폐기전에 코인을 마구 사용했을때의 혼란을 대비해 비트코인은 코인베이스 거래로 생긴 보상금은 모두 99개의 후속 블록이 추가로 만들어질 때까지(즉, 100 확인) 사용하지 못하도록 제한하고 있다. 블록이 폐기될때 일반 트랜잭션들은 무효화가 될뿐, 취소되거나 폐기되지 않는다. 다시 TX Pool 로 돌아간다.

이중 지불(double spending)
- 하나의 비트코인을 여러번 사용하려는 악의적인 시도

스마트 컨트랙트(smart contract)
- 3자의 개입없이 스스로 수행되는 계약(자판기가 예시)

Peer : 노드 중 가지를 통해 직접 연결돼 서로 직접 연결된 노드를 특별히 서로의 peer라고 한다, 전체 노드의 개수는 동일하지만 피어의 개수는 노드별로 모두 다르다.
ex) A의 노드는 C,B와 연결되어있다면 A의 피어는 C,B이다.

완전노드(Full node) : 전체 블록체인 데이터를 완전히 다운로드한 노드, 다른 노드의 도움없이 스스로 거래 검증이 가능하다
단순 지급 겁증 노드(Simple Payment Verification node) : 전체 블록체인 데이터를 다운로드하는 대신 블록의 헤더 정보만 다운로드해 저장하고 있는 노드, 검증에 참여 할 수 없음
                                                        최소한의 정보만 다운로드하고 거래 진행시 다른 풀노드에게 자료를 요청해야한다
                                                        블록 헤더에는 전체 트랜잭션 정보가 아닌 트랜잭션의 정보를 추적할 수 있는 정보만 있다.


Scalability(확장성) : 얼마나 많은 일을 신속히 처리할 수 있는지를 뜻한다.
비트코인과 이더리움에서 확장성에 문제가 있다고하며, 이더리움에서 해결을 해나가겠다고 한다.
확장성에 관련 용어
TPS(Transaction Per Second) : 초당 몇개의 거래 처리하는지
- Visa : TPS 1700
- Bitcoin : TPS 7
- Ethereum : TPS 15 ~ 20
Block Interval : 블록 생성 간격(블록이 생성될떄 어느정도의 간격을 두고 만들어지는가)
- 비트코인 10분
- 이더리움 15 ~ 20초
ex)
ETH : 20 tps + 15초 Block Interval 이라고 가정한다면
20 * 15 = 300 transactions - 한 블록당 300transactions 이 들어가게된다.

검증
- 블록이 생성되면 노드들에게 전파하며 노드들은 블록을 검증한다.
- 생성한 노드가 hash값을 풀어 선정된 노드가 맞는지, 블록에 기록된 트랜잭션이 조작된 것이 아닌지 확인한다.
- 문제가 있는 블록일시(검증 실패 시) 바로 폐기 된다.

Finality : TX(거래)가 변경 불가라는 합리적인 보장받기까지 기다려야하는 시간
블록이 Final하다?
- 블록에 담긴 TX(거래)가 바뀔수없다는걸 보증
- 트랜잭션이 생성되고 검증을거쳐 완벽한 상태가 되는 것
-> 빨리 처리된 Finality는 블록체인에서 엄청난 자산이다.

포크(Fork) : 블록들의 연결이 두개 이상의 분기로 갈라지는 현상
발생이유 : 블록체인 P2P 네트워크에서 모든 참여자들이 독립적으로 채굴을 할 수 있기때문이다
ex) 블록체인상에서 A,B노드가 채굴을 하고 있고 이떄 블록체인상에서 송금 TX가 발생하면 TX는 TX POOL에 추가되고 두개의 노드에서 블록을 추가하기위해 TX POOL에 있는 트랜잭션들을 블록에 추가한다.
이때 블록들에는 송금TX도 포함되어있다. 노드들이 각자가 만든 블록을 블록체인에 추가하기위해 문제를 풀게된다. (해쉬값을 찾는 연산의 과정을 가짐)
이때 두 노드가 동시에 문제를 풀게되고 두 노드가 서로 풀었다고 전파를 하게된다. 이때 어느 노드는 A의 블록을 전파받고, 어느 노드는 B블록을 전파받았고
A의 블록을 받은 노드는 이미 송금TX가 있기때문에 B의 블록을 받지만 무시하게된다, B블록을 받은 노드들도 똑같이 A의 블록을 무시하게된다.
B의 블록을 받은 C의 노드가 블록을 생성하게 되면, C노드는 B블록을 받았기때문에 B노드 라인으로 블록을 추가하게된다.
C노드의 부모해쉬값이 B노드이기때문에 A노드는 블록을 받을수없다.
A노드의 블록을 받은 다른 노드들은 받은 블록을 버리고 다시받아서 B의 블록을 받는다면 C노드의 블록을 받을 수 있게 된다.
분기때 더 길게생성된 라인이 결국 다음 블록으로 인정이되고 블록체인상에 추가가 된다.(Longest Chain Rule 이라고한다.)

* Longest Chain Rule을 악용한게 51% Attack
* 이러한 라인이 길게되면 검증시간도 오래 걸리기때문에 단점이 된다.
이때 분기가 발생하게 된다.

+ 블록체인상에서 소프트웨어가 변경될때(버전이 업그레이드 될떄), 모든 노드가 동시에 업그레이드하는것은 불가능하다, 고로 상당 기간 동안 새로운 버전과 구 버전의 노드가 시스템 상에 존재하며
충돌이 발생할 수 있다.
ex) 
업데이트로 변화가 발생하게 될때 예제의 케이스로 2가지 경우가 발생할때, A그룹은 구버전, B버전은 신버전일때
* 하드포크(Hard Fork) 예시, 과거에 무효하던 규칙이 유효화하는 경우 - 블록 용량이 1메가였는데 2메가까지 허용하도록 바뀌는 예시
- B그룹이 1메가바이트를 넘는 블록을 생성할때 A그룹은 유효하다고 인식하지 못하게된다. 반면 A그룹이 생성하는 블록은 B그룹의 완전 부분 집합이 된다. B그룹이 만든 블록체인 데이터가 A그룹보다 무거워진다면
아래 그림 처럼 서로 다른 블록체인 데이터가 생긴다. 두 블록체인 데이터는 하나로 합쳐질 수 없다. B그룹의 입장에서 A그룹의 블록체인 데이터는 완벽히 유효하지만 B그룹의 블록체인 데이터가 더 무겁기 때문에 합의헤 의해 자신들의 데이터를 선택한다. 두 그룹은 모든 노드가 같은 소프트웨어로 업데이트 하기 전까지는 절대 통일될 수 없다. 동일 버전으로 모든 노드가 업데이트 될시 두 블록체인은 비교하게 되어 궁극적으로 더 무거운 B그룹 블록체인 데이터로 통일될 것이다. A의 모든 노드가 업그레이드 하는데에는 현실적인 문제가 있다, A의 노드가 모두 B로 전환되면 그 순간 새로운 규칙을 도입 이후 A그룹이 생상한 모든 블록은 폐기되고 새로운 블록을 받아들여야한다. 이러면 그동안 블록 보상금도 모두 사라져버린다.

<br>
<div align="center">
Hard Fork
<img src="https://user-images.githubusercontent.com/34171875/64063003-55663d80-cc29-11e9-8deb-e685fdf89810.png"><br>
출처 : https://www.investopedia.com/terms/h/hard-fork.asp<br>
</div>

* 소프트포크(Soft Fork) 예시, 과거에 유효하던 규칙이 무효화하는 경우 - 사용하던 규칙 중 보안 위협을 끼치는 규칙이 발견된 경우
- 완전히 업그레이드 해야만하는 하드포크와 달리, B그룹이 생성한 블록체인 데이터가 조금이라도 더 무거워지면 소프트웨어의 업그레이드와는 상관없이 무조건 새로운 규칙에 맞게 통일된다.
즉 새로운 규칙을 따르는 노드가 이전 규칙을 따르는 노드에 비해 다수가 되는 순간, 모두 새 규칙을 따르게 되는 형태이다. 소프트포크는 새로운 규칙에 찬성하는 그룹이 더 많아져야 성공할 수 있다. B그룹이 블록을 앞서지 못하면 새로운 규칙은 실패로 돌아간다.


TX(Transaction Pool)
- 확인되지 않은 거래(블록체인에 아직  포함되지 않은 거래)가 있는 저장소 같은 엔티티
- 트랜잭션이 발생하고 서로 브로드캐스팅을 통해 트랜잭션을 Transaction pool 에 저장한다.
- 비트코인에서는 mempool 이라고 부른다.
- 각 노드별로 쌓인 트랜잭션 구성이나 순서가 다르다 -> 서로 네트워크 전송속도 등 사양의 차이 때문에

지갑의 역할
- 계정 관리를 위한 개인키/공개키 생성 및 관리
- 거래를 시스템에 제출
- 잔액 관리

해시함수
- 입력길이에 상관없이 항상 고정된 길이의 출력을 생성하는 함수

암호화 해시
- 아래의 4가지 조건을 모두 만족하는 해시함수
1. 계산의 용이성(easy) : 유한의 길이의 메시지 m 를 주었을때 그 메시지에 대한 해시 계산은 매우 간편해야 한다. h = H(m), h는 고정길이
2. 원상 회피(Pre-image resistance) : 어떤 경우라도 해시 값으로부터 원래 메시지를 복원하는 것은 불가능해야 한다.
3. 두번째 원상 회피(Second pre-image resistance) : 주어진 메시지 m에대 대해 이와 동일한 출력을 생성하는 또 다른 메시지 m`를 찾는것은 불가능 해야 한다. 즉 충돌이 불가능하다.
4. 충돌 회피(Collision resistance) : 동일한 출력 결과를 생성하는 서로 다른 두 메시지를 찾는것은 불가능하다.

##### 안전한 해시 함수란 항상 고정된 길이를 출력하되 어떤 경우든 원메시지를 찾을 수 없어야 하며, 입력이 다르면 항상 다른 출력이 달라지는 충돌회피의 성질을 만족해야 한다.

SHA-256 해시 함수
- Secure Hash Algorithm
- 입력에 상관없이 256비트(32바이트)의 출력을 생성한다.

작업증명(PoW, Proof of Work)방식
- 해시 퍼즐의 정답을 찾는 과정은 먼저 블록 틀에 일정 개수의 트랜잭션을 기록한 후 그 블록 전체의 해시 값을 반복적으로 계산한다.
* 해시 퍼즐의 정답을 찾은 후 트랜잭션을 기록하는 것이 아닌, 트랜잭션을 미리 블록 틀에 기록한 후 해시값을 찾는다.
- 블록체인에 블록을 추가하기 위해 문제를 품(Hash 값 찾기)
- 악의적인 해커가 조작하기위해서는 그만큼의 엄청난 에너지가 필요하기때문에 이를 억제하는 방식이다.

지분증명(PoS, Proof of State)방식
- 시스템에 대한 기여도가 높은 사람을 리더로 선출하는 방식, 선출된 노드를 신뢰하는 방식이다.
- 간단한 방법은 현재 보유하고 있는 화폐의 수량이 가장 많은 노드를 리더로 선출하는 방법이지만, 수량에 따라 선출시 선출된노드가 독점하는 형태의 극단 상황으로 가버릴수있다.
- 위의 문제를 해결하기 위해 다양한 형태로 보유 수량과 투표 방식을 혼합한다.
 1. 체인-기반의 지분 증명
 - 사전에 정해진 소수의 집단이 블록을 만들고 검증한다. 집단 중 보유 암호 화폐 수량 등을 고려한 종합 점수가 시스템이 정한 최저 임계치를 넘는 노드들에게 블록 생성권이 주어진다. 임계치를 넘은 노드가 여러개가 되면 동시에 블록이 생성될 수 있으며, 이 경우 가장 무거운 체인을 선택하는 비트코인 탈중앙 합의 규칙을 따른다.
 - 이 방법은 잃을 게 없는 딜레마(nothing-at-stake dilemma) 공격에 노출될 수 있다.
 (블록을 생성하는데 에너지가 소모되지 않아, 무분별한 충돌을 통해 시스템을 남용하는 현상, 공격이 만연할 가능성은 그리 높지 않다.)

 2. BFT-기반의 지분 증명
 - Byzantine Fault Tolerance , 사전에 정해진 소수의 노드중 랜덤으로 선출된 리더가 블록을 생성하고, 나머지 노드는 투표 방식으로 검증해 블록의 최종 승인을 결정한다. 
 - 비트코인의 가장 무거운 체인과 같은 합의 규칙은 존재하지 않는다, BFT기반 지분 증명은 지속적으로 거짓 블록을 생성하는 악의적 노드가 발견되었을때 이를 징벌하기도 한다.
 - 악의적인 노드로 지목되면 그 노드가 보유한 화폐를 모두 폐기해버리는 slashing rule 을 적용하기도 한다.

##### 작업증명(PoW) 대신 지분증명(PoS) 을 사용하는 이유
- 작업증명방식에 막대한 에너지가 소모되기 때문. 지분방식은 에너지를 사용하지 않아도 되는것이 큰 장점이지만 가장 큰 단점이 되기도 한다.
작업증명은 신뢰가 없는 네트워크를 운영하기 위해 어쩔수없이 에너지를 지불한 형태이고, 지분증명은 선출된 노드를 신뢰해야만 작동하기 때문에 에너지 소모가 없다.

위임지분증명방식(DPOS, Delegated POS)방식
- 지분증명에 으한 리더 선출에만 그치지 않고, 생성된 블록의 검증에도 오직 선택된 소수만 참여시키는 배타적 방식
- EOS의 경우 BP(Block Producer)라 불리는 21개의 선출된 노드가 배타적으로 모든 블록생성과 검증을 도맡아 한다.
- 투명성과 안정성을 담보할 수 있는 유일한 장치는 이들을 절대적으로 신뢰하는 것이다.
- 극단적으로 표현하자면 정체가 불분명한 21개의 노드를 신뢰해야하는 중앙화시스템이다.


<br>
<div align="center">
블록의 구조
<img src="https://user-images.githubusercontent.com/34171875/63649047-a979a980-c773-11e9-966a-b109b7e976d4.jpg">
</div>
<strong>블록 구조<strong>
블록의 크기 : 블록의 전체 크기를 나타낸다.
블록 헤더 : 해당 블록의 모든 정보가 요약되어 있다.
블록 내 트랜잭션 개수 : 말 그대로 총 트랜잭션의 개수, 고정적인 크기가 아닌 가변적 크기이다.
블록 내 모든 트랜잭션 내역
<br>
<strong>블록 헤더 구조</strong><br>
버전 : 블록이 만들어질 당시의 시스템 버전, 생성당시의 어떤 규칙을 적용해 블록을 검증했는지 알 수 있다.
이전 블록의 해시 값 : 모든 블록은 자신만의 고유한 해시값을 가지며, 생성된 블록의 이전 블록의 해시값, 현재 생성된 블록의 해시값에도 영향을 준다.
머클트리 루트 해시 : https://steemit.com/kr/@yahweh87/4-merkle-tree-merkle-root
타임 스탬프 : 유닉스 타임(1970년 1월 1일 0시 0분 0초- UTC )로 부터 몇초나 지난것인지를 표현, 358B0553 라면 이만큼의 초가 지난 시간이라는 것,
- 해시에 변화를 주는 입려값으로서의 역할
- 블록체인을 조작하려는 공격이 어렵게 하는 역할
https://jusths.tistory.com/50
http://wiki.hash.kr/index.php/%ED%83%80%EC%9E%84%EC%8A%A4%ED%83%AC%ED%94%84
타깃 난이도 비트, 논스 : https://brunch.co.kr/@skkrypto/2

전자서명
- 디지털화된 문서의 진위를 보장하기 위한 목적
- 위조불가(unforgeable), 인증(authentic) 의 성질을 만족해야 한다.
- 순서 : 1. 송신자는 메시지를 해시 함수를 통해 해쉬값으로 만들고 이를 비밀키와 함께 암호화를 하여 전자서명을 한다.
         2. 만들어진 전자서명과 메시지를 수신자에게 전송한다.
         3. 수신자는 전송받은 전자서명을 공개키로 복호화하여 해시값을 추출, 메시지는 해시 함수를 통해 해시값으로 만든다.
         4. 복호화한 해시값과 메시지로 만든 해시값과 비교한다.

논스(nonce) : 블록체인에서 목표값 이하의 블록 해시를 찾기위해 임시로 사용하는 숫자.

난이도 조절 : 비트코인에서는 2016개의 블록이 생성되면 난이도 조절을 한다. 무어의 법칙을 대비하기 위해서
- 난이도 조절은 목표값을 상향하거나 하향하여 통제하며 늘 10분에 하나만 만들어지도록 하기때문에 예상보다 빠르게 블록이 만들어지면 난이도 상향, 느리게 만들어지면 난이도 하향을 한다.
- 이더리움의 경우 매번 블록이 생성될때 마다 난이도를 조절한다. 블록 생성에 15초가 소요되니 15초마다 난이도를 조절하는셈 이다.
간단한 흐름
- 트랜잭션들이 발생 -> 노드들에게 전파 -> transaction pool 에 담고 블록을 생성하여 해쉬 값 풀기 -> 가장 먼저 풀은 노드가 리더가 선정 -> 생성한 블록을 모든 노드들에게 브로드캐스팅 -> 블록 무결성 검증 실시 -> 블록 이상이 없다면, 노드들은 블록체인 데이터에 이 블록을 추가

UTXO, 전자서명 다시공부
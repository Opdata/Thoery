분산시스템
- 작업의 분산
- 저장의 분산
- 통제서버가 있듯이 모든 노드가 동등하지는 않다.
- 여러 서버가 일을 나눠 처리함으로써 작업의 효율성, 가용성을 높이는 것이 주목적
- 분산된 일을 여러 서버가 처리함으로써 더 빨리 해결하고, 중앙서버가 고장나면 서비스가 중단되는 것을 방지해 가용성을 높이는 기술


탈중앙화 블록체인 시스템
- 작업의 반복
- 저장의 반복
- 모든 노드가 동등하다.
- 분산시스템의 극단적인 형태, 일을 분산해 처리하는 것이 아니라 동일한 일을 중복해 처리
- 더 많은 시간과 자원이 투입되지만, 일을 중복하기 떄문에 효율성이 극도로 저하, 그러나 모든 노드가 일을 반복한 후 결과를 일치시켜서
일에 대한 신뢰도가 향상됨. 즉 작업 효율성을 희생하는 대신 신뢰도를 높인 시스템

-> 네트워크에 참여하는 노드들이 많아져도 속도는 빨라지지 않는다.
-> 탈중앙화 블록체인 시스템이 효율적인 시스템은 아니다.
-> 블록체인의 핵심은 분산이 아닌 중복 이다, 모든 노드가 동등하며 효율을 포기하고 신뢰성을 높이는 시스템
-> 기록을 담당하는 노드를 신뢰하지 못하여 중복을 통해 검증한다.

블록체인은 데이터를 보호하지 못하며, 사용성이 떨어진다
-> 블록체인의 모든 데이터는 전체노드에 그대로 노출되며, 무결성 유지를 위해 데이터의 갱신과 저장이 극도로 불편하다.
-> 블록체인을 정보 저장의 용도로 사용해서는 안된다. (블록체인은 데이터베이스가 아니다) ex 이더리움 The DAO 사건

디지털화폐 : 디지털과 화폐를 조합한 광범위한 단어 ex 유통화폐를 디지털화 한것
암호화폐 : 가상화폐 중 익명성을 보장하기위한 기술이 들어가 있는 것
*모든 암호화폐는 익명성을 지니고 있다, 우리가 일반적으로 은행을 통해 거래하는 디지털화된 원화는 블록체인 기반 혹은 실험적화폐도 아니므로
디지털화폐 혹은 디지털통화로 부름

# 암호화폐 와 디지털화폐는 다른 용어이다.
-> 암호화폐는 수많은 디지털 화폐의 한 종류일 뿐, 암호화폐는 절대적으로 익명성을 가진다. 익명성이 모든 문제의 원인이기도 하다.

#암호화폐는 디지털 자산이 아니다.
-> 디지털자산 : 이미 가치를 갖고 있는 무엇이 디지털로 정보를 변환해 보관하고 있는 것
-> 암호화폐 : 가치를 가지고 있지 않은 것을 디지털화한 디지털 수치, 내재 가치는 '0' 이다.

암호화폐는 자발적인 네트워크가 형성된 후 충분한 채굴자 집단을 구성해 지속적인 채굴 노동을 제공해야 비로소 운영할 수 있다
네트워크를 운영할 참여자를 모집하고 일정 이상의 채굴 집단을 형성해 안정성을 확보하는 것이 지극히 힘들다.
* 이더리움의 경우 스마트 컨트랙트를 사용하여 별도의 네트워크 구성하지 않고 손쉽게 암호화폐를 발행할 수 있다.
-> 이더리움 네트워크를 그대로 활용해 화폐 발행과, 이체도 할 수 있다.

토큰(token) : 일반적인 의미로. 모든 종류의 보상을 통칭하는 광범위한 의미 , 무형의 의미도 포함됨
토큰(token) : 자체 네트워크를 갖추지 않고 이미 발행한 암호화폐를 자체 네트워크로 갖추고 발행된 암호화폐와 구분하기 위해 사용되는 용어
-> 자체네트워크를 메인넷(MainNet) 이라고도 한다.

트랜잭션(transaction) : 정의된 이벤트가 발생하는 것, 일반적인 의미로는 최소한의 업무 처리 단위
-> 중개소에서 이뤄지는 거래내역 같은 것은 트랜잭션이 아니다. 중개소는 자신들의 중앙화 서버에서 거래가 일어난 것처럼 꾸미기만 할뿐 고객의 별도 요청
(아마 지갑송금 등 을 말하는 것으로 예상)이 일어나기 전까지는 블록체인을 통한 거래가 일어나지 않기 떄문.
- 네트워크에 트랜잭션을 먼저 제출했다고 노드에 먼저 도달한다는 보장이 없다. 통상 수수료율이 더 높은 트랜잭션을 먼저 처리한다.
거래내역 : 트랜잭션 중 암호화폐를 서로 주고 받는 이벤트

Peer : 노드 중 가지를 통해 직접 연결돼 서로 직접 연결된 노드를 특별히 서로의 peer라고 한다, 전체 노드의 개수는 동일하지만 피어의 개수는 노드별로 모두 다르다.
ex) A의 노드는 C,B와 연결되어있다면 A의 피어는 C,B이다.

완전노드(Full node) : 전체 블록체인 데이터를 완전히 다운로드한 노드, 다른 노드의 도움없이 스스로 거래 검증이 가능하다
단순 지급 겁증 노드(Simple Payment Verification node) : 전체 블록체인 데이터를 다운로드하는 대신 블록의 헤더 정보만 다운로드해 저장하고 있는 노드, 검증에 참여 할 수 없음
                                                        최소한의 정보만 다운로드하고 거래 진행시 다른 풀노드에게 자료를 요청해야한다
                                                        블록 헤더에는 전체 트랜잭션 정보가 아닌 트랜잭션의 정보를 추적할 수 있는 정보만 있다.


Scalability(확장성) : 얼마나 많은 일을 신속히 처리할 수 있는지를 뜻한다.
비트코인과 이더리움에서 확장성에 문제가 있다고하며, 이더리움에서 해결을 해나가겠다고 한다.
확장성에 관련 용어
TPS(Transaction Per Second) : 초당 몇개의 거래 처리하는지
- Visa : TPS 1700
- Bitcoin : TPS 7
- Ethereum : TPS 15 ~ 20
Block Interval : 블록 생성 간격(블록이 생성될떄 어느정도의 간격을 두고 만들어지는가)
- 비트코인 10분
- 이더리움 15 ~ 20초
ex)
ETH : 20 tps + 15초 Block Interval 이라고 가정한다면
20 * 15 = 300 transactions - 한 블록당 300transactions 이 들어가게된다.

검증
- 블록이 생성되면 노드들에게 전파하며 노드들은 블록을 검증한다.
- 생성한 노드가 hash값을 풀어 선정된 노드가 맞는지, 블록에 기록된 트랜잭션이 조작된 것이 아닌지 확인한다.
- 문제가 있는 블록일시(검증 실패 시) 바로 폐기 된다.

Finality : TX(거래)가 변경 불가라는 합리적인 보장받기까지 기다려야하는 시간
블록이 Final하다?
- 블록에 담긴 TX(거래)가 바뀔수없다는걸 보증
- 트랜잭션이 생성되고 검증을거쳐 완벽한 상태가 되는 것
-> 빨리 처리된 Finality는 블록체인에서 엄청난 자산이다.

Fork : 블록들의 연결이 두개 이상의 분기로 갈라지는 현상
발생이유 : 블록체인 P2P 네트워크에서 모든 참여자들이 독립적으로 채굴을 할 수 있기때문이다
ex) 블록체인상에서 A,B노드가 채굴을 하고 있고 이떄 블록체인상에서 송금 TX가 발생하면 TX는 TX POOL에 추가되고 두개의 노드에서 블록을 추가하기위해 TX POOL에 있는 트랜잭션들을 블록에 추가한다.
이때 블록들에는 송금TX도 포함되어있다. 노드들이 각자가 만든 블록을 블록체인에 추가하기위해 문제를 풀게된다. (해쉬값을 찾는 연산의 과정을 가짐)
이때 두 노드가 동시에 문제를 풀게되고 두 노드가 서로 풀었다고 전파를 하게된다. 이때 어느 노드는 A의 블록을 전파받고, 어느 노드는 B블록을 전파받았고
A의 블록을 받은 노드는 이미 송금TX가 있기때문에 B의 블록을 받지만 무시하게된다, B블록을 받은 노드들도 똑같이 A의 블록을 무시하게된다.
B의 블록을 받은 C의 노드가 블록을 생성하게 되면, C노드는 B블록을 받았기때문에 B노드 라인으로 블록을 추가하게된다.
C노드의 부모해쉬값이 B노드이기때문에 A노드는 블록을 받을수없다.
A노드의 블록을 받은 다른 노드들은 받은 블록을 버리고 다시받아서 B의 블록을 받는다면 C노드의 블록을 받을 수 있게 된다.
분기때 더 길게생성된 라인이 결국 다음 블록으로 인정이되고 블록체인상에 추가가 된다.(Longest Chain Rule 이라고한다.)

* Longest Chain Rule을 악용한게 51% Attack
* 이러한 라인이 길게되면 검증시간도 오래 걸리기때문에 단점이 된다.

이때 분기가 발생하게 된다.

TX POOL or Transaction POOL 이 무었인지 알아놓을것.
TX(Transaction Pool)
- 확인되지 않은 거래(블록체인에 아직  포함되지 않은 거래)가 있는 저장소 같은 엔티티
- 트랜잭션이 발생하고 서로 브로드캐스팅을 통해 트랜잭션을 Transaction pool 에 저장한다.
- 비트코인에서는 mempool 이라고 부른다.
- 각 노드별로 쌓인 트랜잭션 구성이나 순서가 다르다 -> 서로 네트워크 전송속도 등 사양의 차이 때문에

작업증명(PoW)방식
- 해시 퍼즐의 정답을 찾는 과정은 먼저 블록 틀에 일정 개수의 트랜잭션을 기록한 후 그 블록 전체의 해시 값을 반복적으로 계산한다.
* 해시 퍼즐의 정답을 찾은 후 트랜잭션을 기록하는 것이 아닌, 트랜잭션을 미리 블록 틀에 기록한 후 해시값을 찾는다.
- 블록체인에 블록을 추가하기 위해 문제를 품(Hash 값 찾기)



블록의 구조
<br>
<div align="center">
<img src="https://user-images.githubusercontent.com/34171875/63649047-a979a980-c773-11e9-966a-b109b7e976d4.jpg">
</div>


간단한 흐름
- 트랜잭션들이 발생 -> 노드들에게 전파 -> transaction pool 에 담고 블록을 생성하여 해쉬 값 풀기 -> 가장 먼저 풀은 노드가 리더가 선정 -> 생성한 블록을 모든 노드들에게 브로드캐스팅 -> 블록 무결성 검증 실시 -> 블록 이상이 없다면, 노드들은 블록체인 데이터에 이 블록을 추가

